{"data":{"site":{"siteMetadata":{"title":"A blog by derek","author":"Derek"}},"markdownRemark":{"id":"9c8133c2-21b0-5b4e-85df-dc6a51535cdb","excerpt":"闭包（Closure）是词法闭包（Lexical Closure）的简称。\n当一个函数即便在离开了它的词法作用域(Lexical Scope)的情况下，仍然存储并可以存取它的词法作用域(Lexical Scope…","html":"<p>闭包（Closure）是词法闭包（Lexical Closure）的简称。\n当一个函数即便在离开了它的<strong>词法作用域</strong>(Lexical Scope)的情况下，仍然存储并可以存取它的<strong>词法作用域</strong>(Lexical Scope)，这个函数就构成了闭包。</p>\n<blockquote>\n<ul>\n<li>闭包是函数和引用环境组成的整体，是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在</li>\n<li>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配</li>\n<li>当在一个函数内定义另外一个函数就会产生闭包</li>\n</ul>\n</blockquote>\n<!-- more -->\n<p>ECMAScript闭包模型\n在ECMAscript的脚本的函数运行时，每个函数关联都有一个执行上下文场景(Execution Context) ，这个执行上下文场景中包含三个部分</p>\n<blockquote>\n<ul>\n<li>词法环境（The LexicalEnvironment）</li>\n<li>变量环境（The VariableEnvironment）</li>\n<li>this绑定\n词法环境中用于解析函数执行过程使用到的变量标识符。我们可以将词法环境想象成一个对象，该对象包含了两个重要组件，环境记录(Enviroment Recode)，和外部引用(指针)。环境记录包含包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景。全局的上下文场景中此引用值为NULL。这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景。</li>\n</ul>\n</blockquote>\n<p><img src=\"http://coolshell.cn//wp-content/uploads/2012/03/closure.png\" alt=\"cmd-markdown-logo\"></p>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> myClosure <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">outerFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> hidden <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">inc</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token function\">innerFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> hidden<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyClosure<span class=\"token punctuation\">.</span><span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 返回 1</span>\nmyClosure<span class=\"token punctuation\">.</span><span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 返回 2</span>\nmyClosure<span class=\"token punctuation\">.</span><span class=\"token function\">inc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 返回 3</span></code></pre></div>\n<hr>\n<h2>优点</h2>\n<ul>\n<li>希望一个变量长期驻扎在内存中</li>\n<li>避免全局变量的污染</li>\n<li>私有成员的存在</li>\n</ul>\n<h2>缺点</h2>\n<ul>\n<li>空间浪费</li>\n<li>内存泄漏</li>\n<li>性能消耗</li>\n</ul>\n<h3>1. 内存空间浪费</h3>\n<p>内存浪费不仅是因为闭包使得函数中的变量都被保存在内存中，造成内存常驻，还有可能是对闭包使用不当造成无效内存产生。所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露，由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>\n<h3>2. 性能消耗</h3>\n<p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果把父函数当作对像（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>\n<h2>应用场景</h2>\n<ul>\n<li>封装私有变量和方法</li>\n<li>保护函数内的变量安全：如迭代器、生成器</li>\n<li>代码模块化，避免全局变量污染</li>\n</ul>\n<h2>常见错误</h2>\n<h3>循环闭包</h3>\n<p>给多个元素循环绑定事件，用for循环时，不会成功，因为当第一次执行时，i就已经变成最大值，所以不能成功绑定每个元素</p>\n<h3>解决办法</h3>\n<p>用闭包方法，在for循环内使用立即执行函数，!function(i){/<em>执行函数</em>/}(i);。</p>\n<p>参考文献：</p>\n<blockquote>\n<ul>\n<li><a href=\"http://codethoughts.info/javascript/2015/05/22/javascript-closure-inside-out/\">JavaScript 闭包详解</a> </li>\n<li><a href=\"http://blog.leapoahead.com/2015/09/15/js-closure/\">JavaScript闭包的底层运行机制</a> </li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-closure/\">闭包的概念、形式与应用</a> </li>\n</ul>\n</blockquote>","frontmatter":{"title":"JavaScript闭包与应用场景","date":"December 03, 2014","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/JavaScript闭包与应用场景/","previous":{"fields":{"slug":"/前端页面之重绘与回流/"},"frontmatter":{"title":"前端页面之重绘与回流"}},"next":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Hello World"}}}}